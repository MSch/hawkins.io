<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>BroadcastingAdam - Handling Legacy APIs</title>

    
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.2r1/build/reset/reset-min.css">
<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />


    <script type="text/javascript" src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="container">
      <header>
  <h1>BroadcastingAdam</h1>
  <a href="http://feeds.feedburner.com/BroadcastingAdam" id="rss"><img src="images/rss_icon.png" alt="rss" /></a>
  <nav>
    <a href="/">Home</a>
    <a href="/nettuts.html">Nettuts</a>
    <a href="/talks.html">Talks</a>
    <a href="/open_source.html">Open Source</a>
  </nav>
</header>


      <div id="content" class="post">
        <header >
          <h2>Handling Legacy APIs</h2>
          <div class='meta'>
            </p>October 19, 2011 &nbsp; | &nbsp; rails</p>
          </div>
        </header>
        <article>
          <p>Well, it&#8217;s been a while since I&#8217;ve written a post to my blog. I&#8217;m on a plane back to Helsinki for some intense work. I&#8217;ve got some trance on so I figure I&#8217;ll scratch and itch and try to get something written.</p>

<p>There are few things poeple never mention when they are teaching rails to rookies, or hell, really even talk about in general. Rails gets a lot of play for how easy it is to write RESTful APIs. It deserves it. However, no one ever mentions what it <em>actually means</em> to write a web API. I haven&#8217;t see anyone talk about freezing input formats or output formats. The common approach is to just throw in <code>respond_to :json</code> then go on your merry way. It works, but it&#8217;s got some problems.</p>

<h2 id='dealing_with_changes'>Dealing with Changes</h2>

<p>Let&#8217;s first examine the most basic and widely adverised Rails RESTful API controlller.</p>

<pre><code>class FoosController &lt; ApplicationController
  respond_to :json

  def new
    respond_with Foo.create(params[:foo])
  end

  def show
    respond_with Foo.find params[:id]
  end

  def index
    respond_with Foo.all
  end

  def update
    foo = Foo.find params[:id]

    respond_with foo.update_attributes(params[:foo])
  end

  def destroy
    foo = Foo.find params[:id]

    respond_with foo.destroy
  end
end</code></pre>

<p><strong>Zomg!</strong> You have an API! Well, no. You&#8217;ve just defined a simple webservice that communicates with JSON. You have not met the two fundamental requirements for writing an API:</p>

<ol>
<li>Input parameters stay the same forever for a given API version</li>

<li>Output formats stay the same forever for a given API version.</li>
</ol>

<p>Let&#8217;s say you change an attribute on the <code>Foo</code> class. You&#8217;ll likely be smacked with a lof of <code>UnknownAttribute</code> errors. Then on the other end, there previous parameter will be renamed in the outputted JSON. Congratulations, you&#8217;ve just made an API that has Facebook consistency. As the developer, you need to take steps to ensure that you&#8217;re API stays to the standards you&#8217;ve written.</p>

<p>You have two ways to handle this problem. You can build logic into the underlying model to handle deprecated methods. You could code some logic into the controller to convert legacy input parameters. You could write a middleware that will handle some changes. There are a few ways to tackel this problem. I&#8217;ll share how I did it for Radium.</p>

<h2 id='handling_legacy_api_input_parameters'>Handling Legacy API Input Parameters</h2>

<p>A long time ago. I wrote a webservice for a Symbian (kill it with fire) application. The API was supposed to exist for maybe a few months for prototyping. Turns out it&#8217;s taken over 1.5 years to develop (and it&#8217;s not done yet) the application. In that time, my simple API interface to some common models has had to stay the same. You can imagine over the course of 1.5 years the underyling schema and model layer will undergo changes. For examples, one record use to a series to timestamps and a state machine to track it&#8217;s progress. Now there is a simple boolean flag. Attributes have been renamed. Classes have changed. The underlying data model has matured but the API hadn&#8217;t. Now I&#8217;m facing a problem with supporting legacy input parameters and legacy output formats. I was using the wonderful <code>to_json</code> method.</p>

<p>I needed to take different param hashes, change values, rename keys, and some various other massaging to fit current model. So I decided to write a class for each different type of API call. There are todos, contacts, and meetings. Here is a snippet of one of the classes:</p>

<pre><code>module SymbianAPI
  class LegacyTodoConverter
    def self.convert(params)
      params[:finished] = true if params.delete(:finished_at)
      params[:description] = params.delete :task
      params[:finish_by] = params.delete :due_at

      # more stuff

      params
    end
  end
end</code></pre>

<p>I ended up writing 3 of these type&#8217;s of classes. They massage the legacy params for the API request and update them to fit the current model.</p>

<p>I took a more complicated route implementing them. I wanted my controllers to look as vanilla as possible. I didn&#8217;t want to have to reference these classes in every request or write a <code>before_filter</code>. I just wanted the controller to know that <code>params[:foo]</code> is good to go. I dedecied to write a middleware that would automatically convert the legacy parameters based on the route. So if the route mataches <code>/api/customers</code>, then I would use my LegacyCustomerConvertor to merge in the new params. There is some other trickery going on here, but I figure I&#8217;d share the code for anyone who is interested.</p>

<pre><code>class SymbianApiAdapter
  def initialize(app)
    @app = app
  end

  def call(env)
    if request_for_symbian_api?(env)
      @app.call convert_legacy_input(env)
    else
      @app.call env
    end
  end

  private 
  def request_for_symbian_api?(env)
    parts = env[&#39;PATH_INFO&#39;].split(&#39;/&#39;)
    parts[1] == &#39;api&#39; &amp;&amp; parts[2] != &#39;v2&#39;
  end

  def convert_legacy_input(env)
    # No fucking clue why we have to do this trickery for PUTS
    if env[&#39;REQUEST_METHOD&#39;] == &#39;PUT&#39;
      params = Rack::Request.new(env).POST
    else
      params = env[&#39;rack.request.form_hash&#39;]
    end

    if params.present? &amp;&amp; params[&#39;xml&#39;].present?
      adapter = case env[&#39;PATH_INFO&#39;]
                when &#39;/api/todos/sync&#39;
                  Api::Adapters::TodosAdapter
                when /todo/
                  Api::Adapters::TodoAdapter
                when &#39;/api/meetings/sync&#39;
                  Api::Adapters::MeetingsAdapter
                when /meeting/
                  Api::Adapters::MeetingAdapter
                when &#39;/api/customers/sync&#39;
                  Api::Adapters::CustomersAdapter
                when /customer/
                  Api::Adapters::CustomerAdapter
                end

      env[&#39;rack.request.form_hash&#39;] || {}

      if adapter
        xml = params.delete &#39;xml&#39;
        hash = Hash.from_xml(xml)

        if hash.values.first.is_a?(Hash)
          converted_params = {}
          converted_params[hash.keys.first] = adapter.convert(hash.values.first.with_indifferent_access)
          env[&#39;rack.request.form_hash&#39;].merge! converted_params
        elsif hash.values.first.is_a?(Array)
          env[&#39;rack.request.form_hash&#39;].merge! adapter.convert(hash)
        end
      end
    end

    env
  end
end</code></pre>

<p>This keeps my controllers small since they don&#8217;t have to worry about handling the paramters. They are just correct when the request finally hits the controller. Now there is also a wall between what comes in from the request and what actually hits the models. This makes it much easier to <strong>ensure future support</strong>. All I need to do is update those convertor classes and things will continue. Now at this point I can write this controller action and never worry about the params.</p>

<pre><code>class FoosController &lt; ApplicationController
  respond_to :json

  def create
    reapond_with Foo.create(params[:foo])
  end
end</code></pre>

<h2 id='handling_legacy_api_output_formats'>Handling Legacy API Output Formats</h2>

<p>There has finally been some talk about this sort of thing. There needs to be a way to easily generate different blocks of JSON depending on what API version is in use&#8211;essentially different <strong>views</strong>. There are a few ways to do this. You could use a fancy new JSON builder like Rabl. I have not used Rabl. I investigated it, but I find that using builders in views is cumbersom when you need to write some code. (And code doesn&#8217;t belong the view anyway). I opted for an easier approach. (And given that this is currently a Rails 2 app, there are no other options). I wrote another three classes that take the record to be returned and generate an output hash. That hash can then be used for <code>to_json</code> or <code>to_xml</code>. Here&#8217;s how they work.</p>

<pre><code>module Api
  class LegacyContactAdapter
    def self.convert(contact)
     {
      :town =&gt; contact.city, # API was specified to return a &#39;town&#39; attribute
      :postcode =&gt; contact.zip_code # API specificed a &#39;postcode&#39; attribute

      # so on and so forth. Build up the hash with the specified
      # attributes
    }
  end
end</code></pre>

<p>Now, the controller can use that class to return the required JSON.</p>

<pre><code>def create
  foo = Foo.create params[:foo]

  if foo.save
    respond_to do |wants|
      wants.json { render :json =&gt; Api::LegacyContactAdapter.convert(contact), :status =&gt; :created }
    end
  else
    respond_to do |wants|
      wants.json { render :json =&gt; contact.errors, :status =&gt; :unprocessable_entity }
    end
  end</code></pre>

<p>Using that classes ensure that it&#8217;s easy(ier) to support the legacy API into the future because there is a wall in the code. Also, if the contact model ever changes, or the api needs a new output paramter, you can just throw it into the various <code>Adapter</code> classes.</p>

<h2 id='wrapping_it_up'>Wrapping it Up</h2>

<p>Writing API&#8217;s is serious business. They represent a contact between your system and external developers. You need to do everything in your power to ensure that you hold up your end of the baragin. You need to ensure that the input parameters are always accepted and that you stick to the given output format no matter what changes. I&#8217;ve showed you some different ways you can hold up your end of the contract. A middleware based solution may not work in every situation. I could&#8217;ve easily used a <code>before_filter</code> but I didn&#8217;t like that. The important thing is to build walls between the API and the other parts of your code that way it&#8217;s easier to ensure support in the future.</p>

          <h3>Contact Me</h3>
          <p>
            Find a problem or have a question about this post? <a href="http://twitter.com/adman65/">@adman65</a> on
            Twitter or Adman65 on #freenode. Find me in (#rubyonrails or
            #sproutcore). You can find my code on <a href="http://github.com/twinturbo/">GitHub</a> or hit me up on
            <a href="https://plus.google.com/u/0/116377228668850173159">Google+</a>.
          </p>
        </article>
      </div>
    </div>

    <script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '4eb0f672613f5d482f000001');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

  </body>
</html>
