<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Advanced Caching in Rails</title>
    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.2r1/build/reset/reset-min.css">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/style.css" />
    <script type="text/javascript" src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="container">
      <header>
        <h1>BroadcastingAdam</h1>
        <a href="http://feeds.feedburner.com/BroadcastingAdam" id="rss"><img src="images/rss_icon.png" alt="rss" /></a>
        <nav>
          <a href="/">Home</a>
          <a href="/nettuts.html">Nettuts</a>
        </nav>
      </header>
      <div id="content" class="post">
        <header >
          <h2>Advanced Caching in Rails</h2>
          <div class='meta'>
            </p>May 06, 2011 &nbsp; | &nbsp; rails tutorials</p>
          </div>
        </header>
        <article>
          <p>Caching in Rails is covered occasionally. It is covered in very basic detail in the caching <a href='http://guides.rubyonrails.org/caching_with_rails.html'>guide</a>. Advanced caching is left to reader. Here&#8217;s where I come in. I recently read part of Ryan Bigg&#8217;s <a href='http://www.manning.com/katz/'>Rails 3 in Action</a> upcoming Rails book (review in the works) where he covers caching. He does a wonderful job of giving the reader the basic sense of how you can use page, action, and fragment caching. The examples only work well in a simple application like he&#8217;s developing in the book. I&#8217;m going to show you how you can level up your caching with some new approaches.</p>

<h2 id='different_caching_layers'>Different Caching Layers</h2>

<p>First, let&#8217;s start with a brief overview of the different types of caching:</p>

<p>1. Page Caching: <strong>PRAISE THE GODS</strong> if you actually can use page caching in your application. Page caching is the holy grail. Save the entire thing. Don&#8217;t hit the stack &amp; give some prerendered stuff back. Great for worthless applications without authentication and other highly dynamic aspects.</p>

<p>2. Action Caching: Essentially the same as page caching, except all the before filters are run allowing you to check authentication and other stuff that may have prevented the request for rendering.</p>

<p>3. Fragment Caching: Store parts of views in the cache. Usually for caching partials or large bits of HTML that are independent from other parts. IE, a list of top stories or something like that.</p>

<p>4. Rails.cache: All cached content <strong>except cached pages</strong> are stored in the Rails.cache. Cached pages are stored as HTML on disk. We&#8217;ll use the fact that all the cached action and fragment content are simply stored in Rails.cache. You can cache arbitrary content in the Rails cache. You may cache a large complicated query that you don&#8217;t want to wait to reinstantiate a ton of AR::Base objects.</p>

<h2 id='under_the_hood'>Under the Hood</h2>

<p>All the caching layers are built on top of the next one. Page caching is the only exception because it does not use <code>Rails.cache</code> it writes content to disk. The cache is essentially a key-value store. Different things can be persisted. Strings are most common (for HTML fragments). More complicated objects can be persisted as well. Let&#8217;s go through some examples of manually using the cache to store things. I am using memcached with dalli for all these examples. Any driver that implements the cache store pattern should work.</p>

<pre><code># Rails.cache.write takes two value: key and a value
&gt; Rails.cache.write &#39;foo&#39;, &#39;bar&#39;
=&gt; true

# We can read an object back with read
&gt; Rails.cache.read &#39;foo&#39;
=&gt; &quot;bar&quot;

# We can store a complicated object as well
&gt; hash = {:this =&gt; {:is =&gt; &#39;a hash&#39;}}
&gt; Rails.cache.write &#39;complicated-object&#39;, object
&gt; Rails.cache.read &#39;complicated-object&#39;
=&gt; {:this=&gt;{:is=&gt;&quot;a hash&quot;}}

# If we want something that doesn&#39;t exist, we get nil
&gt; Rails.cache.read &#39;we-havent-cached-this-yet&#39;
=&gt; nil

# &quot;Fetch&quot; is the most common pattern. You give it a key and a block
# to execute to store if the cache misses. The block is not executed
# if there is a cache hit.
&gt; Rails.cache.fetch &#39;huge-array&#39; do
    huge_array = Array.new
    1000000.times { |i| huge_array &lt;&lt; i }
    huge_array # retrun value is stored in cache
  end
=&gt; [huge array] # took some time to generate
&gt; Rails.cache.read &#39;huge-array&#39;
=&gt; [huge array] # but returned instantly

# You can also delete everything from the cache
&gt; Rails.cache.clear 
=&gt; [true]</code></pre>

<p>Those are the basics of interacting withe the Rails cache. The rails cache is a wrapper around whatever functionality is provided by the underlying storage system. Now we are ready to move up a layer.</p>

<h2 id='understanding_fragment_caching'>Understanding Fragment Caching</h2>

<p>Fragment caching is taking rendered HTML fragments and storing them in the cache. Rails provides a <code>cache</code> view helper for this. It&#8217;s most basic form takes no arguments besides a block. Whatever is rendered during the block will be written back to the cache. The basic principle behind fragment caching is that it takes much less time fetch pre-rendered HTML from the cache, then it takes to generate a fresh copy. This is very true. If you haven&#8217;t noticed, view generation can be very costly. Let&#8217;s say you have generated a basic scaffold for a post:</p>

<pre><code>$ rails g scaffold post title:string content:text author:string
# that will generate some views to play with</code></pre>

<p>Let&#8217;s start with the most common use case: caching information specific to one thing. IE: One post. Here is a show view:</p>

<pre><code>&lt;!-- nothing fancy going on here --&gt;
&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Content:&lt;/b&gt;
  &lt;%= @post.content %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Author:&lt;/b&gt;
  &lt;%= @post.author %&gt;
&lt;/p&gt;</code></pre>

<p>Let&#8217;s say we wanted to cache fragment. Simple wrap it in <code>cache</code> and Rails will do it.</p>

<pre><code>&lt;%= cache &quot;post-#{@post.id}&quot; do %&gt;
  &lt;p&gt;
    &lt;b&gt;Title:&lt;/b&gt;
    &lt;%= @post.title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;b&gt;Content:&lt;/b&gt;
    &lt;%= @post.content %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;b&gt;Author:&lt;/b&gt;
    &lt;%= @post.author %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>

<p>The first argument is the key for this fragment. The rendered HTML is stored with this key: <code>views/posts-1</code>. Wait what? Where did that &#8216;views&#8217; come from? The <code>cache</code> view helper automatically prepends &#8216;view&#8217; to all keys. This is important later. When you first load the page you&#8217;ll see this in the log:</p>

<pre><code>Exist fragment? views/post-2 (1.6ms)
Write fragment views/post-2 (0.9ms)</code></pre>

<p>You can see the key and the operations. Rails is checking to see if the specific key exists. It will fetch it or write it. In this case, it has not been stored so it is written. When you reload the page, you&#8217;ll see a cache hit:</p>

<pre><code>Exist fragment? views/post-2 (0.6ms)
Read fragment views/post-2 (0.0ms)</code></pre>

<p>There we go. We got HTML from the cache instead of rendering it. Look at the response times for the two requests:</p>

<pre><code>Completed 200 OK in 17ms (Views: 11.6ms | ActiveRecord: 0.1ms)
Completed 200 OK in 16ms (Views: 9.7ms | ActiveRecord: 0.1ms)</code></pre>

<p>Very small differences in this case. 2ms different in view generation. This is a very simple example, but it can make a world of difference in more complicated situations.</p>

<p>You are probably asking the question: &#8220;What happens when the post changes?&#8221; This is an excellent question! What well if the post changes, the cached content will <strong>not</strong> be correct. It is up to <strong>us</strong> to remove stuff from the cache <strong>or</strong> figure out a way to get new content from the cache. Let&#8217;s assume that our blog posts now have comments. What happens when a comment is created? How can handle this?</p>

<p>This is a very simple problem. What if we could figured out a solution to this problem: How can we create a cache miss when the associated object changes? We&#8217;ve already demonstrated how we can explicitly set a cache key. What if we made a key that&#8217;s dependent on the time the object was last updated? We can create a key composed of the record&#8217;s ID and it&#8217;s updated_at timestamp! This way the cache key will change as the content changes <strong>and we will not have to expire things manually.</strong> (We&#8217;ll come back to sweepers later). Let&#8217;s change our cache key to this:</p>

<pre><code>&lt;% cache &quot;post-#{@post.id}&quot;, @post.updated_at.to_i do %&gt;</code></pre>

<p>Now we can see we have a new cache key that&#8217;s dependent on the objects timestamps. Check out the rails log:</p>

<pre><code>Exist fragment? views/post-2/1304291241 (0.5ms)
Write fragment views/post-2/1304291241 (0.4ms)</code></pre>

<p>Cool! Now let&#8217;s make it so creating a comment updates the post&#8217;s timestamp:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  belongs_to :post, :touch =&gt; true
end</code></pre>

<p>Now all comments will touch the post and change the <code>updated_at</code> time stamp. You can see this in action by <code>touch</code>&#8216;ing a post.</p>

<pre><code>Post.find(1).touch

Exist fragment? views/post-2/1304292445 (0.4ms)
Write fragment views/post-2/1304292445 (0.4ms)</code></pre>

<p>This concept is known as: <strong>auto expiring cache keys.</strong> You create a composite key with the normal key and a time stamp. This will create some memory build up as objects are updated and no longer create cache hits. For example. You have that fragment. It is cached. Then someone updates the post. You now have two versions of the fragment cached. If there are 10 updates, then there are 10 different versions. Luckily for you, this is not a problem for memcached! Memcached uses a LRU replacement policy. LRU stands for Least Recently Used. That means the key that hasn&#8217;t been request in the longest time will be replaced with new content needs to be stored. For example, assume your cache can only hold 10 posts. The next update will create a new key and hence new content. Version 0 will be deleted and version 11 will be stored in the cache. The total amount of memory is cycled between things that are requested. There are two things to consider in this approach. 1: You will not be able to ensure that content is kept in the cache as long as possible. 2. You will never have to worry about expiring things manually as long as timestamps are updated in the model layer. I&#8217;ve found it is orders of magnitude easier to add a few <code>:touch =&gt; true</code>&#8217;s to my relationships than it is to maintain sweepers. More on sweepers later. We must continue exploring cache keys.</p>

<p>Rails uses auto-expiring cache keys by <strong>default.</strong> The problem is they are not mentioned at all the documentation or in the guides. There is one very handy method: <code>ActiveRecord::Base.cache_key</code>. This will generate a key like this: <code>posts/2-20110501232725</code>. <strong>This is the exact same thing we did ourselves.</strong> This method is very important because depending on what type of arguments you pass into the <code>cache</code> method it will be called on them. For the time being, this code is functionally equal to our previous examples.</p>

<pre><code>&lt;%= cache @post do %&gt;</code></pre>

<p>The <code>cache</code> helper takes different forms for arguments. Here are some examples:</p>

<pre><code>cache &#39;explicit-key&#39;      # views/explicit-key
cache @post               # views/posts/2-1283479827349
cache [@post, &#39;sidebar&#39;]  # views/posts/2-2348719328478/sidebar
cache [@post, @comment]   # views/posts/2-2384193284878/comments/1-2384971487
cache :hash =&gt; :of_things # views/localhost:3000/posts/2?hash_of_things</code></pre>

<p>If an <code>Array</code> is the first arguments, Rails will use cache key expansion to generate a string key. This means calling doing logic on each object then joining each result together with a &#8217;/&#8217;. Essentially, if the object responds to <code>cache_key</code>, it will use that. Else it will do various things. Here&#8217;s the source for <code>expand_cache_key</code>:</p>

<pre><code>def self.expand_cache_key(key, namespace = nil)
  expanded_cache_key = namespace ? &quot;#{namespace}/&quot; : &quot;&quot;

  prefix = ENV[&quot;RAILS_CACHE_ID&quot;] || ENV[&quot;RAILS_APP_VERSION&quot;]
  if prefix
    expanded_cache_key &lt;&lt; &quot;#{prefix}/&quot;
  end

  expanded_cache_key &lt;&lt;
    if key.respond_to?(:cache_key)
      key.cache_key
    elsif key.is_a?(Array)
      if key.size &gt; 1
        key.collect { |element| expand_cache_key(element) }.to_param
      else
        key.first.to_param
      end
    elsif key
      key.to_param
    end.to_s

  expanded_cache_key
end</code></pre>

<p>This is where all the magic happens. Our simple fragment caching example could easily be converted into an idea like this: The post hasn&#8217;t changed, so cache the entire result of /posts/1. You can do with this action caching or page caching.</p>

<h2 id='moving_on_to_action_caching'>Moving on to Action Caching</h2>

<p>Action caching is an around filter for specific controller actions. It is different from page caching since before filters are run and may prevent access to certain pages. For example, you only want to cache if the user is logged in. If the user is not logged in they should be redirect to the log in page. This is different than page caching. Page caching bypasses the rails stack completely. Most web applications for legitimate complexity cannot use page caching. Action caching is the next logical step for most web applications. Let&#8217;s break the idea down: If the post hasn&#8217;t changed, return the entire cached page as the HTTP response, else render the show view, cache it, and return that as the HTTP response. Or in code:</p>

<pre><code>Rails.cache.fetch &#39;views/localhost:3000/posts/1&#39; do
  @post = Post.find params[:id]
  render :show
end</code></pre>

<p>Declaring action caching is easy. Here&#8217;s how you can cache the show action:</p>

<pre><code>class PostsController &lt; ApplicationController

  caches_action :show

  def show
    # do stuff
  end
end</code></pre>

<p>Now refresh the page and look at what&#8217;s been cached.</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 16:54:43 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2 (0.5ms)
Rendered posts/show.html.erb within layouts/application (6.1ms)
Write fragment views/localhost:3000/posts/2 (0.5ms)
Completed 200 OK in 16ms (Views: 8.6ms | ActiveRecord: 0.1ms)</code></pre>

<p>Now that the show action for post #2 is cached, refresh the page and see what happens.</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 16:55:27 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2 (0.6ms)
Completed 200 OK in 1ms</code></pre>

<p>Damn. 16ms vs 1ms. You can see the difference! You can also see Rails reading that cache key. <strong>The cache key is generated off the url with action caching.</strong> Action caching is a combination of a before and around filter. The around filter is used to capture the output and the before filter is used to check to see if it&#8217;s been cached. It works like this:</p>

<ol>
<li>Execute before filter to check to see if cache key exists?</li>

<li>Key exists? - Read from cache and return HTTP Response. This triggers a <code>render</code> and <strong>prevents any further code from being executed.</strong></li>

<li>No key? - Call all controller and view code. Cache output using Rails.cache and return HTTP response.</li>
</ol>

<p>Now you are probably asking the same question as before: &#8220;What do we do when the post changes?&#8221; We do the same thing as before: we create a composite key with a string and a time stamp. The question now is, how do we generate a special key using action caching?</p>

<p>Action caching generates a key from the current url. You can pass extra options using the <code>:cache_path</code> option. Whatever is in this value is passed into <code>url_for</code> using the current parameters. Remember in the view cache key examples what happened when we passed in a hash? We got a much different key than before:</p>

<pre><code>views/localhost:3000/posts/2?hash_of_things</code></pre>

<p>Rails generated a URL based key instead of the standard views key. This is because you may different servers and things like that. This ensures that each server has it&#8217;s own cache key. IE, server one does not collide with server 2. We could generate our own url for this resource by doing something like this:</p>

<pre><code>url_for(@post, :tag =&gt; @post.updated_at.to_i)</code></pre>

<p>This will generate this url:</p>

<pre><code>http://localhost:3000/posts/1?tag=234897123978</code></pre>

<p>Notice the &#8216;?tag=23481329847&#8217;. Look familiar from anywhere? Rails uses this method to tag GET urls for static assets. That way the browser does not send a new HTTP request when it sees &#8216;application.css?1234&#8217; since it is caching it. We can use this strategy to with action caching as well.</p>

<pre><code>caches_action :show, :cache_path =&gt; proc { |c|
  # c is the instance of the controller. Since action caching
  # is declared at the class level, we don&#39;t have access to instance
  # variables. If cache_path is a proc, it will be evaluated in the
  # the context of the current controller. This is the same idea
  # as validations with the :if and :unless options
  #
  # Remember, what is returned from this block will be passed in as
  # extra parameters to the url_for method.
  post = Post.find c.params[:id]
  {:tag =&gt; post.updated_at.to_i}
end</code></pre>

<p>This calls <code>url_for</code> with the parameters already assigned by it through the router and whatever is returned by the block. Now if you refresh the page, you&#8217;ll have this:</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 17:11:22 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Rendered posts/show.html.erb within layouts/application (1.7ms)
Write fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Completed 200 OK in 16ms (Views: 4.4ms | ActiveRecord: 0.1ms)</code></pre>

<p>And volia! Now we have an expiring cache key for our post! Let&#8217;s dig a little deeper. We know the key. Let&#8217;s look into the cache and see what it actually is! You can see the key from the log. Look it up in the cache.</p>

<pre><code>&gt; Rails.cache.read &#39;views/localhost:3000/posts/2?tag=1304292445&#39;
=&gt; &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;.....&quot;</code></pre>

<p>It&#8217;s just a straight HTML string. Easy to use and return as the body. This method works well for singular resources. How can we handle the index action? I&#8217;ve created 10,000 posts. It takes a good amount of time to render that page on my computer. It takes over 10 seconds. The question is, how can we cache this? We could use the most recently updated post for the time stamp. That way, when one post is updated, it will move to the top and create a new cache key. Here is the code without any action caching:</p>

<pre><code>Started GET &quot;/posts&quot; for 127.0.0.1 at 2011-05-01 17:18:11 -0700
  Processing by PostsController#index as HTML
  Post Load (54.1ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; ORDER BY updated_at DESC LIMIT 1
Dalli::Server#connect localhost:11212
Read fragment views/localhost:3000/posts?tag=1304292445 (1.5ms)
Rendered posts/index.html.erb within layouts/application (9532.3ms)
Write fragment views/localhost:3000/posts?tag=1304292445 (36.7ms)
Completed 200 OK in 10088ms (Views: 9535.6ms | ActiveRecord: 276.2ms)</code></pre>

<p>Now with action caching:</p>

<pre><code>Started GET &quot;/posts&quot; for 127.0.0.1 at 2011-05-01 17:20:47 -0700
  Processing by PostsController#index as HTML
Read fragment views/localhost:3000/posts?tag=1304295632 (1.0ms)
Completed 200 OK in 11ms</code></pre>

<p>Here&#8217;s the code for action caching:</p>

<pre><code>caches_action :index, :cache_path =&gt; proc {|c|
  post = Post.order(&#39;updated_at DESC&#39;).limit(1).first
  {:tag =&gt; post.updated_at.to_i}
}</code></pre>

<p>These are simple examples designed to show you who can create auto expiring keys for different situations. At this point we have not add to expire any thing ourselves! The keys have done it all for us. However, there are some times when you want more precise control over how things exist in the cache. Enter Sweepers.</p>

<h2 id='sweepers'>Sweepers</h2>

<p>Sweepers are HTTP request dependent observers. They are loaded into controllers and observer models the same way standard observers do. However there is one very important different. <strong>They are only used through HTTP requests.</strong> This means if you have things being created outside the context of HTTP requests sweepers will do you know good. For example, say you have a background process running that syncs with an external system. Creating a new model will not make it to any sweeper. So, if you have anything cached. It is up to you to expire it. Everything I&#8217;ve demonstrated so far can be done with sweepers.</p>

<p>Each <code>cache_*</code> method has an opposite <code>expire_*</code> method. Here&#8217;s the mapping:</p>

<ol>
<li>caches_page , expire_page</li>

<li>caches_action , expire_action</li>

<li>cache , expire_fragment</li>
</ol>

<p>Their arguments work the same with using cache_key_expansion to find a key to read or delete. Depending on the complexity of your application, it may be very to use sweepers or it may be impossible. Our simple examples can use sweepers easily. We only need to tie into the save event. For example, when a update or delete happens we need to expire the cache for that specific post. When a create, update, or delete happens we need to expire the index action. Here&#8217;s what a the sweeper would look like:</p>

<pre><code>class PostSweeper &lt; ActionController::Caching::Sweeper
  observe Post

  def after_create(post)
    expire_action :index
    expire_action :show, :id =&gt; post
    # this is the same as the previous line
    expire_action :controller =&gt; :posts, :action =&gt; :show, :id =&gt; @post.id
  end
end

# then in the controller, load the sweeper
class PostsController &lt; ApplicationController
  cache_sweeper :post_sweeper
end</code></pre>

<p>I will not go into much depth on sweepers because they are the only thing covered in the rails caching guide. The work, but I feel they are clumsy for complex applications. Let&#8217;s say you have comments for posts. What do you do when a comment is created for a post? Well, you have to either create a comment sweeper or load the post sweeper into the comments controller. You can do either. However, depending on the complexity of your model layer, it may quickly infeasible to do cache expiration with sweepers. For example, let say you have a Customer. A customer has 15 different types of associated things. Do you want to put the sweeper into 15 different controllers? You can, but you may forget to at some point.</p>

<p>The real problem with sweepers is that they cannot be used once your application works outside of HTTP requests. They can also be clumsy. I personally feel it&#8217;s much easier to create auto expiring cache keys and only uses sweepers when I want to tie into very specific events.</p>

<p>Now you should have a good grasp on how the Rails caching methods work. We&#8217;ve covered how fragment caching uses the current view to generate a cache key. We introduced the concept of auto expiring cache keys using <code>ActiveRecord#cache_key</code> to automatically expire cached content. We introduced action caching and how it uses <code>url_for</code> to generate a cache key. Then we covered how you can pass things into <code>url_for</code> to generate a time stamped key to expire actions automatically. We&#8217;ve skipped page caching because it&#8217;s not applicable to many Rails applications. Now that we understand how caching works we can address shortcomings in the system.</p>

<h2 id='moving_away_from_the_http_request'>Moving Away from the HTTP Request</h2>

<p>Now we&#8217;re going to write some code to address problems in the Rails caching system. We know that action caching is dependent on URLS. Fragment caching is dependent on the view being rendered. However, we know that both of these methods use <code>Rails.cache</code> under the covers to store content. We can use <code>Rails.cache</code> any where in our code. Unlike <code>caches_path</code>, <code>caches_action</code> and <code>cache</code> that will no hit the cache if <code>perform_caching</code> is set to false, the <code>Rails.cache</code> methods will <strong>always</strong> execute against the cache. Ideally, it would be nice to create a simple observer for our models. What it would be cool if we had a class like this:</p>

<pre><code>class Cache 
  def self.expire_page(*args)
    # do stuff
  end

  def self.expire_action(*args)
    # do stuff
  end

  def self.expire_fragment(*args)
    # do stuff
  end
end</code></pre>

<p>Then we can use that utility class anywhere in our code to expire different things we have cached. First, we need to be able to generate URL&#8217;s from something other than a controller. You may be familiar with this problem. Mailers are not controllers, but you can still generate URL&#8217;s. You need a host name to generate paths. The controller have this information because they accept HTTP requests which have that information. Mailer do not. That&#8217;s why the host name must be configured in the different environments. We can create a frankenstein class that takes parts of ActionMailer to generate URLS. Once we can generate URL&#8217;s we can expire pages and actions. URL generation is included this module <code>Rails.application.routes.url_helpers</code>. That&#8217;s a shortcut method for the generated module which contains <code>url_for</code>, <code>path_for</code> and all the named route helpers. We also need a class level variable for the host name. Here&#8217;s what we can do so far:</p>

<pre><code>class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(*args)
    # do stuff
  end

  def expire_fragment(*args)
    # do stuff
  end
end</code></pre>

<p>Now we can pull in some knowledge on how the cache system works to fill in the gaps. Some of this comes from reading the various source files and observation in generating the cache keys. Here is the complete class:</p>

<pre><code># will not work in Rails 2 -- Rails 3 only!
class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(key, options = {})
    expire(key, options)
  end

  def expire_fragment(key, options={})
    expire(key, options)
  end

  private
  def caching_enabled?
    return ActionController::Base.perform_caching
  end

  def expire(key, options = {})
    return unless caching_enabled?
    Rails.cache.delete expand_cache_key(key), options
  end

  def expand_cache_key(key)
    # if the key is a hash, then use url for
    # else use expand_cache_key like fragment caching
    to_expand = key.is_a?(Hash) ? url_for(key).split(&#39;://&#39;).last : key
    ActiveSupport::Cache.expand_cache_key to_expand, :views
  end
end</code></pre>

<p>Since action and fragment caching all use Rails.cache under the hood, we can simply generate the keys ourselves and remove them manually&#8211;all without the fuss of HTTP Requests. Now you can create an initializer to define a method on your application namespace so it&#8217;s globally accessible. I like this way because it&#8217;s easy to reference in any piece of code.</p>

<pre><code># config/initializers/cache.rb
require &#39;cache&#39;

module App # whatever you application module is
  class &lt;&lt; self
    def cache
      @cache ||= Cache.new
    end

    def expire_fragment(*args)
      cache.expire_fragment(*args)
    end

    def expire_action(*args)
      cache.expire_fragment(*args)
    end
  end
end</code></pre>

<p>Now we can merrily go about our business expiring cached content from <strong>anywhere.</strong> Here are some examples:</p>

<pre><code>App.cache # reference to a Cache instance

App.expire_fragment @post
App.expire_fragment [@post, &#39;sidebar&#39;]
App.expire_fragment &#39;explicit-key&#39;

# in a controller
App.expire_fragment post_url(@post)
# Have to pass in the hash since it&#39;s most likely
# that you won&#39;t have access to the url helpers
# in whatever scope your&#39;re in.
App.expire_action :action =&gt; :show, :controller =&gt; :posts, :id =&gt; @post, :tag =&gt; @post.updated_at.to_i</code></pre>

<p>The <code>expire_fragment</code> and <code>expire_action</code> methods work just like the ones described in the Rails guides. Only difference is, you can use them anywhere. Now we can easily call this code in an observer. The observer events will fire every time they happen <strong>anywhere in the codebase.</strong> Here&#8217;s an example. I am assuming a todo is created outside an HTTP request through a background process. The observer will capture the event.</p>

<pre><code>class TodoObserver &lt; ActivRecord::Observer
  def after_create
    App.expire_fragment :controller =&gt; :todos, :action =&gt; :index
  end
end</code></pre>

<p>The beauty here is that we can use this code anywhere. If you have more complicated cache expirations you may have to use a background job. This may not be acceptable because of processing time, but in some situations you can afford a sweeping delay if the sweeping process takes a long time. You could easily use this code with DelayedJob or Resque if needed. After all, the generated rails code does reference a cache observer&#8211;now you know how to write one.</p>

<h2 id='tagged_based_caching'>Tagged Based Caching</h2>

<p>This is an approach I came up with to work in this situation:</p>

<ol>
<li>Maintain control over how long things are cached</li>

<li>Large number of different associations. Actions or fragments no longer related to a specific resource.</li>

<li>Content could be invalidated through HTTP requests or any number of background process.</li>

<li>Hard to maintain specific keys. I thought of it as &#8220;resources&#8221;.</li>
</ol>

<p>There is a ton of cached content in the system. Many different actions and fragments. There was also a cache hierarchy. Expiring a specific fragment would have to expire an action (so a cache miss would occur when a page was requested thus, causing the new fragment to be displayed) while other things on pages are still cached. One question to ask, is how can I expire groups of things based on certain events? Well, first you need a way to associate different keys. Once you can associate different keys, then you can expire them together. Since you&#8217;re tracking the keys being sent to <code>Rails.cache</code>, you can simply use <code>Rails.cache</code> to delete them. All of this is possible through one itty-bitty detail of the Rails caching system.</p>

<p>You may have noticed something in the <code>Cache</code> class in the previous section. There is a second argument for <code>options</code>. Anything in the <code>option</code> argument is passed to the cache store. This is where can tie in the grouping logic. Also, since action and fragment caching use the same mechanism to write to the cache, we simply have to override the <code>write_fragment</code> method to add our tagging logic.</p>

<p>Through all of this trickery, you&#8217;ll be able to express this type of statement:</p>

<pre><code>App.cache.expire_tag &#39;stats&#39; 
App.cache.expire_tag @account</code></pre>

<p>The content could from anywhere, but all you know is that&#8217;s stale.</p>

<p>This is exactly where <a href='http://rubygems.org/gems/cashier'>Cashier</a> comes in. It is (my gem) that allows you associate actions and fragments with one or more tags, then expire based of tags. Of course you can expire the cache from anywhere in your code. Here are some examples:</p>

<pre><code>caches_action :stats, :tag =&gt; proc {|c|
  &quot;account-#{Account.find(c.params[:id]).id}&quot;
}

caches_action :show, :tag =&gt; &#39;account&#39;
caches_cation :show, :tag =&gt; %w(account customer)

&lt;%= cache @post, :tag =&gt; &#39;customer&#39; do %&gt;</code></pre>

<p>Then you can expire like this:</p>

<pre><code>Cashier.expire &#39;account&#39; # wipe all keys tagged &#39;account&#39;</code></pre>

<p>All this is possible through this module:</p>

<pre><code>module Cashier
  module ControllerHelper
    def self.included(klass)
      klass.class_eval do
        def write_fragment_with_tagged_key(key, content, options = nil)
          if options &amp;&amp; options[:tag] &amp;&amp; Cashier.perform_caching? 
            tags = case options[:tag].class.to_s
                   when &#39;Proc&#39;, &#39;Lambda&#39;
                     options[:tag].call(self)
                   else 
                     options[:tag]
                   end
            Cashier.store_fragment fragment_cache_key(key), *tags
          end
          write_fragment_without_tagged_key(key, content, options)
        end
        alias_method_chain :write_fragment, :tagged_key
      end
    end
  end
end</code></pre>

<p>I higly recommend you checkout <a href='http://rubygems.org/gems/cashier'>Cashier</a>. It may be useful in your application especially if you have complicated relationships with high performance requirements.</p>

<h2 id='caching_complicated_actions_or_methods'>Caching Complicated Actions (or Methods)</h2>

<p>Let&#8217;s say you have an index action. However, it&#8217;s more complicated than a normal scaffold index. The user can search, filer, sort and apply different query options. Think for example a form build with MetaWhere or Sunspot. There are infinite number of combinations, but the data is always the same. That is, a search for &#8220;EC2&#8221; will always have the same results as another search for &#8220;EC2&#8221; as long as the underlying data hasn&#8217;t changed. We could easily cache the index action if we could figured how to represent each unique combination of input parameters as a key value. Memcached also has a key length limit. I don&#8217;t know what it is off the top of my head, but you should try to keep the key short. How can we do this? We use a <strong>cryptographic hash.</strong> A cryptographic hash is guaranteed to be unique given a unique set of input parameters. This means there no collisions.</p>

<pre><code>hash(key1) != hash(key2) # will always be true</code></pre>

<p>The Ruby Standard Library comes with SHA1. SHA1 is good hashing function so we&#8217;ll have no problems using it for these examples. It takes a string input and generates a hash. We&#8217;ll create a composite key with a timestamp and string representation of the input parameters.</p>

<p>require &#8216;digest/sha1&#8217;</p>

<p>class ComplicatedSearchController &lt; ApplicationController</p>

<pre><code>caches_action :search, :cache_path =&gt; proc {|c|
  timestamp = Model.most_recently_updated.updated_at
  string = timestamp + c.params.inspect
  {:tag =&gt; Digest::SHA.hexdigest(string)}
}</code></pre>

<p>end</p>

<p>That will cache every combination of input parameters you can throw at it. This is perfect for actions with pagination as well. It&#8217;s perfect for anything that uses the same underlying data based on input parameters. This can save your bacon if a search takes a few seconds. If one user just did the same search, the second user won&#8217;t have to wait at all. Hell, they might even be impressed.</p>

<h2 id='bringing_caching_into_the_model_layer'>Bringing Caching into the Model Layer</h2>

<p>Caching isn&#8217;t just for views. Some DB operations or methods make be computationally intensive. We can use <code>Rails.cache</code> inside the models to make them more efficient. Let&#8217;s say you wanted to cached the listing of all the top 100 posts on reddit.</p>

<pre><code>class Post
  def self.top_100
    timestamp = Post.most_recently_updated.updated_at
    Rails.cache.fetch [&#39;top-100&#39;, timestamp.to_i&#39;].join(&#39;/&#39;) do
      order(&#39;vote_count DESC&#39;).limit(100).all
    end
  end
end</code></pre>

<p>I&#8217;ve used the <code>most_recently_updated</code> method a few times. It is not a defined method, but a method named so that you understand what it is doing. We can use these concepts to do more fun stuff. My main project has companies and customers. An account has many customers and companies. It&#8217;s typical that I need to retrieve all the customers per an account. This can be 10000 records. That takes time. ActiveRecord instantiation on that order is not free. However, I only care about customers or companies in the scope of a specific account. That means, I only use the account and customers/companies association. Rails gives you the ability to specific a different attribute for <code>:touch</code> on <code>belongs_to</code>. I use this to my advantage to create an &#8216;association_name_updated_at&#8217; column. Then specify :touch =&gt; &#8216;association_name_updated_at&#8217;. Here&#8217;s how it looks in code:</p>

<pre><code>class Account &lt; ActiveRecord::Base
  has_many :customers
end

class Customers &lt; ActiveRecord::Base
  belongs_to :account, :touch =&gt; :customers_updated_at
end</code></pre>

<p>That gives me a timestamp I can use to generate all keys. Now I can use Rails.cache to fetch different queries and keep them all cached. You can wrap this functionality in a module and include in other associations.</p>

<pre><code>require &#39;digest/sha1&#39;

module CachedFinderExtension
  def cached(options = {})
    key = Digest::SHA1.hexdigest(options.to_s)
    association_name = proxy_reflection.name
    owner_key = [proxy_owner.class.to_s.underscore, proxy_owner.id].join(&#39;/&#39;)
    tag = proxy_owner.send(&quot;#{association_name}_updated_at&quot;).to_i

    Rails.cache.fetch [owner_key, association_name, tag, key].join(&#39;/&#39;) do
      all options
    end
  end
end</code></pre>

<p><code>all</code> is a method that takes many options. We don&#8217;t really care what&#8217;s passed in, we just need to be able to generate a cache key based on the input parameters. Since we know when the association was last updated, the method will return fresh content depending if records have been modified. Include the extension in your association and you&#8217;re on your way!</p>

<pre><code>class Account &lt; ActiveRecord::Base
  has_many :customers, :extend =&gt; CachedFinderExentsion
end

# all find&#39;s now automatically cached and expired
@account.customers.cached(:conditions =&gt; {:name =&gt; &#39;Adam&#39;})
@account.customers.cache(:order =&gt; &#39;name ASC&#39;, :limit =&gt; 10})</code></pre>

<p>These are just examples of what you can do with caching in the model layer. You could even write the type of cached finder extension for ActiveRecord::Base. This is different from SQL caching since it only persists through request&#8211;this is cached throughout the entire application.</p>

<h2 id='csrf_and_form_authenticty_token'>CSRF and form_authenticty_token</h2>

<p>Rails uses a CSRF (Cross Site Request Forgery) token and a form authentic token to protect your application against attacks. These are generated per request and each pages get unique values each time. <code>protect_from_forgery</code> is added by default to <code>ApplicationController</code>. You may have run into the problem before. You may have tried to submit a POST and received an Unauthorized response. This is the <code>form_authenticity_token</code> in action. You can fiddle with it and see what happens to your application.</p>

<p>These tokens cause problems (depending on what Rails version) you&#8217;re using with cached HTML. Caching a page or an action with a form may generate unauthorized errors because the tokens were for a different session or request. There are parts of the cached pages that need to be <em>replaced</em> with new values before the application can be used. This is a simple process, but it will take another HTTP request.</p>

<p>You&#8217;ll need to create a controller to server up some configuration related information that&#8217;s never cached. That way, a cached action will load, then a separate request will be made for correct tokens.</p>

<p>NOTE: You may run into more problems with on Rails 2. This is because Rails 3 uses a form authenticity token and CSRF in a meta tag in the HEAD of the document. This is for AJAX requests. You may notice the rails.js file appends them to all AJAX requests. Forms submitted with AJAX with something like <code>$(form).serialize()</code> will send the <code>form_authenticty_token</code> since it&#8217;s automatically included in all forms generated with <code>form_for</code> or <code>form_tag</code>.</p>

<p>You need to create a new controller that responds_to JavaScript and return some JS for the browser to evaluate. Here&#8217;s how you can replace the information in the meta tag for Rails 3. You can also use this logic to update all <code>form_authenticty_token</code> inputs on the page.</p>

<pre><code>$(&quot;meta[name=&#39;csrf-token&#39;]&quot;).attr(&#39;content&#39;, &#39;&lt;% Rack::Utils.escape_html(request_forgery_protection_token) %&gt;&#39;);
$(&quot;meta[name=&#39;csrf-param&#39;]&quot;).attr(&#39;content&#39;, &#39;&lt;% Rack::Utils.escape_html(form_authenticity_token) %&gt;&#39;);

// you may also want to supply current application status as well.
// for example, you may want to know the current users&#39;s ID
// for use in your application JS
MyApp.userId = &#39;&lt;%= current_user.id %&gt;&#39;;</code></pre>

<h2 id='dealing_with_relative_dates_or_other_content'>Dealing with Relative Dates (or other content)</h2>

<p>Many Rails applications use <code>distance_of_times_in_words</code> throughout their application. This can cause major problems for any cached content with a data. For example, you have a fragment cached. That fragment was cached 1 month ago. 2 months ago, it&#8217;s still in the cache. Since you stored a relative date in the cache, the fragment contains &#8216;1 month ago&#8217;. This is no good. You can solve this problem easily with JavaScript.</p>

<p>JavaScript is better for handling dates/times than Rails is. This is because Rails needs to know what the user&#8217;s time zone is, then marshal all times into that time zone. JavaScript is better because it use the local time zone by default. How often do you want to display a time in a different zone than user&#8217;s current locale? You can dump the UTC representation of the date into the DOM, then use JS to parse them into relative or something like <code>strftime</code>. I&#8217;ve encapsulated this process in a helper in my Rails applications. Once all the data is in the DOM, you can do all the parsing in JavaScript.</p>

<pre><code>def timestamp(time, options = {})
  classes = %w(timestamp)
  classes &lt;&lt; &#39;past&#39; if time.past?
  classes &lt;&lt; &#39;future&#39; if time.future?

  options[:class] ||= &quot;&quot;
  options[:class] += classes.join(&#39; &#39;)

  content_tag(:span, time.utc.iso8601, options)
end</code></pre>

<p>Then, when the page loads you can use a library like date.js to create more user friendly dates.</p>

<h2 id='time_to_cash_out'>Time to Cash Out</h2>

<p>I&#8217;ve covered a ton of material in this article. I&#8217;ve given a through explanation of how all the Rails cache layers fit together and how to use the lowest level to it&#8217;s full potential. I&#8217;ve provided a solution for managin the cache outside the HTTP request cycle as well as shown you how to bring caching into the model layer. This is not the be-all-and-all of caching in Rails. It is a indepth look at caching in a Rails application. I&#8217;ll leave you with a quick summary of everything covered and some few goodies.</p>

<h3 id='page_caching'>Page Caching</h3>

<ol>
<li>The honest to goodness best caching ever. Bypass Rails completely.</li>

<li>Usually not applicable to any web application. Have a form? No good, the <code>form_authenticity_token</code> will be no good and Rails will reject it.</li>
</ol>

<h3 id='action_caching'>Action Caching</h3>

<ol>
<li>Most bang for the buck. Can usually be applied in many different circumstances.</li>

<li>Uses fragment caching under the covers.</li>

<li>Generates a cache key based off the current url and whatever other options are passed in</li>

<li>Get more mileage by caching actions with an composite timestamped key.</li>
</ol>

<h3 id='fragment_caching'>Fragment Caching</h3>

<ol>
<li>Good for caching reusable bits of HTML. Think shared partials or forms.</li>

<li>Use a good cache key for each cache block.</li>

<li>Don&#8217;t go overboard. Requests to memcached are not free. Maximize benefits by caching a small number of large fragments instead of a large number of small fragments.</li>

<li>Use auto expiring cache keys to invalidate the cache automatically.</li>
</ol>

<h3 id='general_points'>General Points</h3>

<ol>
<li>Don&#8217;t worry about sweepers unless you have too.</li>

<li>Understand the limitations of Rail&#8217;s HTTP request cycle</li>

<li>Use cryptographic hashes to generate cache keys when permutations of input parameters are invloved.</li>

<li>Don&#8217;t be afraid to use Rails.cache in your models.</li>

<li>Only use sweepers when you have to.</li>

<li>Tagged based caching is useful in certain situations.</li>

<li>Conslidate your cache expritation logic in one place so it&#8217;s easily testable.</li>

<li>Test with caching turned on in complex applications.</li>

<li>Look into <a href='http://www.varnish-cache.org/'>Varnish</a> for more epic wins.</li>

<li>belongs to with <code>:touch =&gt; true</code> is your friend.</li>

<li>Use association timestamps</li>

<li>Spend time upfront considering your cache strategy.</li>

<li>Be weary of examples with expire by regex. This only works on cache stores that have the ability to iterate over all keys. <strong>Memcached</strong> is not one of those.</li>
</ol>

          <h3>Contact Me</h3>
          <p>
            Find a problem or have a question about this post? <a href="http://twitter.com/Adman65/">@Adman65</a> on
            Twitter or Adman65 on #freenode. Find me in (#rubyonrails or
            #sproutcore). You can find my code on <a href="http://github.com/Adman65/">GitHub</a> or hit me up on
            <a href="https://plus.google.com/u/0/116377228668850173159">Google+</a>.
          </p>
        </article>
      </div>
    </div>
    <script type="text/javascript">
      var _gauges = _gauges || [];
      (function() {
        var t   = document.createElement('script');
        t.type  = 'text/javascript';
        t.async = true;
        t.id    = 'gauges-tracker';
        t.setAttribute('data-site-id', '4eb0f672613f5d482f000001');
        t.src = '//secure.gaug.es/track.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(t, s);
      })();
    </script>
  </body>
</html>
