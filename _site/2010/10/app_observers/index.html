<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>BroadcastingAdam</title>
    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.2r1/build/reset/reset-min.css">
    <link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
    <script type="text/javascript" src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="container" class='no-header'
      <header>
        <nav>
          <a href="/">Home</a>
          <a href="/nettuts.html">Nettuts</a>
        </nav>
      </header>
      <div id="content" class="post">
        <header >
          <h2>app/observers -- Where They Should Be</h2>
          <div class='meta'>
            </p>October 09, 2010 &nbsp; | &nbsp; ruby rspec</p>
          </div>
        </header>
        <article>
          <p>Afer you&#8217;ve been doing Rails for a while you become old and cranky about how you want things. I <em>love</em> my observers in /app/obsevers. I do not understand why they are not their by default. Models, mailers, and controllers all have their own folders, why can&#8217;t observers by default. They don&#8217;t even make any sense in /app/models. #1 They don&#8217;t model anything and #2 They aren&#8217;t subclasses of ActiveRecord (or some other ORM). If all the classes in /app/models are subclasses of AR, then what is an observer breaks the pattern. In Rails 2 if you want to specify another directory to load code from you have to specify add it to the <code>config.load_path</code> variable. This is not the case in Rails 3. If you simply want to shove your observers into /app/observers, jsut make the directory and move the files in there. You will have to move them if you don&#8217;t patch the <code>rails g observer</code> command to generate them in a new directory. That takes care of Rails, but now that we have our observers separated, it&#8217;s safe to assume we want to be able to run <code>rake spec:obsevers</code>. This is not a problem either. All you have to do is create a rake spec task to only run files in spec/observers. So drop this bad boy in /lib/tasks</p>

<pre><code>require &#39;rspec/core&#39;
require &#39;rspec/core/rake_task&#39;
Rake.application.instance_variable_get(&#39;@tasks&#39;)[&#39;default&#39;].prerequisites.delete(&#39;test&#39;)

spec_prereq = Rails.configuration.generators.options[:rails][:orm] == :active_record ?  &quot;db:test:prepare&quot; : :noop

namespace :spec do
  [:observers].each do |sub|
    desc &quot;Run the code examples in spec/#{sub}&quot;
    RSpec::Core::RakeTask.new(sub =&gt; spec_prereq) do |t|
      t.pattern = &quot;./spec/#{sub}/**/*_spec.rb&quot;
    end
  end
end</code></pre>

<p>Now we have our own rake task for testing our observers. But let&#8217;s take it one step further and make our observer specs a first class citizen in Rspec2. You know that when you write controller specs you can call the <code>controller</code> method or in helper specs there is a <code>helper</code> object that represents the object under test. This magic happens because rspec contains special code that runs when initial describe block matches something like xxxController or xxxHelper. If it matches, it loads some special code to make writing specs for these classes much easier. All you have to do is take a peek into the rspec-rails <a href='http://github.com/rspec/rspec-rails/tree/master/lib/rspec/rails/example/'>source</a> to see where the magic happens. I advice you to look at those files and figure out what&#8217;s up. Creating a new observer example group is easy. Drop this bad boy in side /spec/support/observer_example_group.rb</p>

<pre><code>module RSpec::Rails
  module ObserverExampleGroup    
    extend ActiveSupport::Concern
    extend RSpec::Rails::ModuleInclusion

    include RSpec::Rails::RailsExampleGroup

    def observer
      example.example_group.describes.instance
    end

    included do
      metadata[:type] = :observer
    end

    RSpec.configure &amp;include_self_when_dir_matches(&#39;spec&#39;,&#39;observers&#39;)
  end
end</code></pre>

<p>This module adds some sugar to all specs in an observer example group. If your spec is in spec/observers you can now do something like this:</p>

<pre><code>describe AccountObserver do
  it &quot;should send a welcome email&quot; do
     AccountMailer.should_receive(:welcome_email).and_return(mock_mail)
     mock_mail.should_receive(:deliver)
     observer.after_create(mock_account) # notice observer is defined in the observer example group
  end
end</code></pre>

<p>Nice! We no longer have to call AccountObserver.instance in all our tests or set an @observer in a before filter. This also allows us to do some more cool stuff for our observer examples. You can include support modules for certian example by doing something like this in your spec_helper.rb file</p>

<pre><code>config.include ControllerHelpers, :type =&gt; :controller</code></pre>

<p>Now we can do that for observers as well! You may by thinking where the hell did those mock_account and mock_email methods come from? You define then in an obesrver helper module inside the support directory then tell rspec to include them for all observers like so. First create this file: spec/support/observer_helpers.rb</p>

<pre><code>module ObserverHelpers
  def mock_account(stubs = {}) 
    @mock_account ||= mock_model(Account, stubs)
  end

  def mock_mail(stubs = {}) 
    @mock_mail ||= mock(Mail, stubs)
  end
end</code></pre>

<p>Now in your spec helper:</p>

<pre><code>config.include ObserverHelpers, :type =&gt; :observer</code></pre>

<p>Poof! All done. Now you can go on your way running rake spec:observers and treating your observer specs as first class citizens w/Rspec2. Happy testing.</p>
        </article>
      </div>
    </div>
  </body>
</html>
