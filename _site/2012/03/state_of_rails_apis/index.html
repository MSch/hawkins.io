<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>BroadcastingAdam - State of Writing API Servers with Rails</title>

    
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.2r1/build/reset/reset-min.css">
<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />


    <script type="text/javascript" src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="container">
      <header>
  <h1>BroadcastingAdam</h1>
  <a href="http://feeds.feedburner.com/BroadcastingAdam" id="rss"><img src="images/rss_icon.png" alt="rss" /></a>
  <nav>
    <a href="/">Home</a>
    <a href="/nettuts.html">Nettuts</a>
    <a href="/talks.html">Talks</a>
    <a href="/open_source.html">Open Source</a>
  </nav>
</header>


      <div id="content" class="post">
        <header >
          <h2>State of Writing API Servers with Rails</h2>
          <div class='meta'>
            </p>March 28, 2012 &nbsp; | &nbsp; rails api</p>
          </div>
        </header>
        <article>
          <p>We&#8217;ve been writing API&#8217;s using Rails for a long time. It&#8217;s nothing new. However, making the API the sole and only reason to exist shifts your application&#8217;s purpose and architecture. This posts covers my experience writing pure JSON APIs with Rails.</p>

<h2 id='defining_an_api_server'>Defining an &#8220;API Server&#8221;</h2>

<p>This is what I consider a pure API server.</p>

<ol>
<li>All responses are JSON</li>

<li>Authentication using some sort of tokens</li>

<li><code>ActionView</code> is not present in the code base.</li>

<li><code>Sprockets</code> is not present in the code base.</li>

<li>Some concept of versioning (inputs and outputs)</li>
</ol>

<p>I think this covers a pretty basic Rails app.</p>

<h2 id='existing_tries'>Existing Tries</h2>

<p>There are already a few things that try to make writing a API with rails easier. Basically they all just create less complicated version of <code>ApplicationController::Base</code> and do some other basic stuff. <a href='https://github.com/strobecorp/strobe-rails-ext'>Strobe&#8217;s Rails Extension</a> does this. It&#8217;s a basic solution, but not complete enough. There are a host of similar solutions out there. Take a peak around if you like.</p>

<h2 id='getting_in_the_door_authentication'>Getting in the Door: Authentication</h2>

<p>The primary method is using a token. The token is passed to the API through headers (preferred) or standard parameter passing. Here is the code I use to generate API keys in all my applications.</p>

<pre><code>module HasApiToken
  extend ActiveSupport::Concern

  included do
    before_create :generate_api_key
  end

  private
  def generate_api_key
    self.api_key ||= Digest::SHA1.hexdigest(Time.now.to_s + attributes.inspect)
  end
end</code></pre>

<p>Then you can authenticate a request using the token like this:</p>

<pre><code>User.find_by_api_key!(request.headers[&#39;HTTP_X_API_TOKEN&#39;] || params[:token])</code></pre>

<p>Easy. I&#8217;m not sure if this pattern could be wrapped up in a gem because it&#8217;s very simple but it doesn&#8217;t change much. Either way, this technique gets the job done.</p>

<h2 id='getting_it_done_generating_json'>Getting it Done: Generating JSON</h2>

<p>Your API has return JSON. It&#8217;s very surprising to me that some solutions make this so damn complicated (I&#8217;m looking at you JBuilder and Rabl). Returning JSON is a very simple process. You only need to generate a Hash. This is done very easily via the Presenter pattern. The presenter also needs to take the <code>current_user</code> into account since different people get to see different things. The presenter pattern is perfect because you can define a different presenter class for each resource and even scope them under different namespaces when you need to version things.</p>

<p>I use <a href='https://github.com/josevalim/active_model_serializers'>ActiveModel::Serializers</a> because it&#8217;s the perfect solution. It&#8217;s very easy to define schemas and test them independently of everything else. This is very important! It seems to me that people forget this. OOP is good. Use it!</p>

<p>Here is an example serializer:</p>

<pre><code>class BlogPostSerializer &lt; ActiveModel::Serializer
  attributes :title, :content, :posted_at

  has_many :comments

  def attributes
    hash = super

    # include secret if the user is an admin
    hash[:secret] = object.secret if user.admin?
    hash
  end
end</code></pre>

<p>You can test this very easily. Instantiate it with a blog post and user and test that <code>as_json</code> returns the right stuff. No view layer. No bullshit. Just classes following SRP. If you use Ember (which is awesome), <code>ActiveModel::Serializers</code> will be be the default format for the data store. Rails will automatically use the proper serializer when using <code>respond_with</code> or <code>respond_to</code>.</p>

<p>I advise you to use ActiveModel::Serializers because it&#8217;s a very simple solution. You can easily define &#8220;partials&#8221; in modules that declare more attributes. Unfortunately, there is only a 0.1.0 release out now. The project is still under active development.</p>

<h2 id='next_step_parameter_santization_and_authorization'>Next Step: Parameter Santization and Authorization</h2>

<p><a href='https://github.com/rails/strong_parameters'>Strong Paramters</a> is a good first step in moving authorization out of the model. I hope that dhh&#8217;s strong paramters is merged into Rails 4. It&#8217;s a basic variation on the slice pattern. It uses a method inside the controller to select the valid parameters that can be sent to the model.</p>

<p>Here is the important example from the readme:</p>

<pre><code>class PeopleController &lt; ActionController::Base
  # This will raise an ActiveModel::ForbiddenAttributes exception because it&#39;s using mass assignment
  # without an explicit permit step.
  def create
    Person.create(params[:person])
  end

  # This will pass with flying colors as long as there&#39;s a person key in the parameters, otherwise
  # it&#39;ll raise a ActionController::MissingParameter exception, which will get caught by 
  # ActionController::Base and turned into that 400 Bad Request reply.
  def update
    redirect_to current_account.people.find(params[:id]).tap do |person|
      person.update_attributes!(person_params)
    end
  end

  private
    # Using a private method to encapsulate the permissible parameters is just a good pattern
    # since you&#39;ll be able to reuse the same permit list between create and update. Also, you
    # can specialize this method with per-user checking of permissible attributes.
    def person_params
      params.required(:person).permit(:name, :age)
    end
end</code></pre>

<p>I think that this is a step in the right direction, but I&#8217;d like to see this logic moved into it&#8217;s own class. StrongParameters doesn&#8217;t consider authorizations that may happen outside of a controller. It does make it possible to extract the <code>person_params</code> method into it&#8217;s own class. You <strong>should</strong> do this.</p>

<h2 id='action_authorization'>Action Authorization</h2>

<p>There is only one thing to say: <a href='https://github.com/ryanb/cancan'>CanCan</a>. It is the best thing for this. I think CanCan is almost perfect.</p>

<h2 id='versioning'>Versioning</h2>

<p>Enter the no-mans land. I still haven&#8217;t found any that will handle versioning in a clean way. I&#8217;m looking for something that builds boundaries in my code. I&#8217;m looking for something that completely separates the request input and request response. For example, say in version API version 2, the parameters to <code>POST /foos</code> have changed. How do you handle that? IMO, you need a class that can convert the message. Same thing for output formats. How do you handle returning a different format for version 2? You <em>could</em> be a slacker and namespace routes (<code>/api/v1/</code>, <code>/api/v2</code>). I don&#8217;t think this is a good solution. The version should be passed in the headers, not in the URI. It would be perfect if I could find a gem that would take the Accept header and automatically use <code>V2::Messages</code> and <code>V2::PostSerializer</code>.</p>

<h2 id='documentation'>Documentation</h2>

<p>Documenting programs is hard. It is always hard no matter the context. I think there are two different types of documentation. There is the exact technical documentation. For example, this route takes this parameter. This parameter must be this format or these values etc. These are return values etc. Then there is the high level user guide type documentation. Think the rails guides vs the API docs. You need both to create a successful platform.</p>

<p>The major difference between them is that one is generated from documentation in the code and the other is written by humans. At this point it is infeasible that user guides can be generated automatically. It is feasible that technical documentation can be generated. Isn&#8217;t the holy grail that you can change the code and have the documentation updated? The big problem with documentation is that it gets out of date because it&#8217;s maintained in two separate places. What if could solve that problem?</p>

<p>I think we can solve this problem. The first step, as with any code documentation, is to define a standard format and where to put it. I think you can put this code in the controller. Why the controller? Because the controller is where your API meets the outside world. The controller is what takes input and tells other classes to do stuff. Also, the controller may do specific logic on parameters to sanitize them or something else. The controller is the gatekeeper for your application and the entry rules should be written on the gate. Now you can combine this parameter declaration with parameter sanitization (ala StrongParamters) and you&#8217;d really be onto something!</p>

<p>Here is an example from <a href='https://github.com/mifo/sinatra-rabbit'>Rabbit</a>. This doesn&#8217;t do everything that I&#8217;m talking about, but you&#8217;ll see where I&#8217;m going:</p>

<pre><code>operation :show do
  description &quot;Index operation description&quot;
  param :id,  :string, :required
  param :r1,  :string, :optional, &quot;Optional parameter&quot;
  param :v1,  :string, :optional, [ &#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39; ], &quot;Optional parameter&quot;
  param :v2,  :string, :optional, &quot;Optional parameter&quot;
  control do
    &quot;Hey #{params[:id]}&quot;
  end
end</code></pre>

<p>At this point you could load the code and read the declarations. Everything you need is there. You could write code to transform it into <a href='http://petstore.swagger.wordnik.com/'>http://swagger.wordnik.com/</a>. How awesome would that be? This is just an example of what can be done. The important part is updating the code regenerates the documentation.</p>

<p>We still have to handle the user guide level documentation. I think there are two ways to handle it. #1, you use something like <a href='http://tomdoc.org/'>Tomdoc</a> in the controller for high level documentation. #2, you maintain it separately. I&#8217;ve opted for #2 in my situation. I&#8217;m using my own code here to write <a href='https://github.com/threadedlabs/api_guides'>api guides</a>. It&#8217;s heavily inspired by Stripe&#8217;s <a href='https://stripe.com/docs/api'>docs</a>. You can see an example <a href='http://developer.radiumcrm.com'>here</a>.</p>

<p>Unfortunately, I haven&#8217;t been able to solve the generated technical documentation problem yet, but at least this is a start.</p>

<p>I think there is a lot to be done on this front. If we as a community can solve this problem, I think that crafting API&#8217;s will be much easier and more importantly, much faster.</p>

<h2 id='get_going'>GET /going</h2>

<p>I think there is still much work to be done on this front. I hope that Rails 4 takes some of these ideas and folds them into the core. I know that parameter authorization will be moved to the controller in Rails 4. I hope they address the serialization problem as well (by not using JBuilder). However, given DHH&#8217;s love for it, I don&#8217;t see that happening.</p>

<p>I&#8217;d really like to see the community address the documentation problem. I think there is a will too. It seems to me that more rails developers are building simple applications and aren&#8217;t really interested in tackling the entire scope of the problem: How can build an HTTP API in rails, maintain it, and release it to the public. At Radium, we are building enterprise software. We think big. Working in this scope has made me tackle many large problems. I hope that my experience will help you as well.</p>

<p>When building an API, just remember: Rails is not your code. Your application is separate. The controllers just talk to your code. Don&#8217;t get the two confused!</p>

<p>Now in the vein of &#8220;Sharing is Caring&#8221;, here is my base API controller that I use:</p>
<script src='https://gist.github.com/2237832.js?file=api_controller.rb' />
<h2 id='appendex'>Appendex</h2>

<p>I&#8217;ve added this section to include links to things people have tweeted me or showed me on IRC.</p>

<ul>
<li><a href='https://github.com/intridea/grape'>Grape</a> - Github</li>

<li><a href='https://github.com/mifo/sinatra-rabbit'>Rabbit</a> - Github</li>

<li><a href='https://github.com/bploetz/versionist'>Versionist</a> - Github</li>

<li><a href='http://freelancing-gods.com/posts/versioning_your_ap_is'>Versioning RESTful APIs</a> - Blog Post</li>

<li><a href='http://designinghypermediaapis.com/'>Hypermedia APIs</a> - Book</li>

<li><a href='https://github.com/rails/rails/commit/6db930cb5bbff9ad824590b5844e04768de240b1'>Rails API Mode</a> - Reverted Commit for API mode for rails</li>
</ul>

          <h3>Contact Me</h3>
          <p>
            Find a problem or have a question about this post? <a href="http://twitter.com/adman65/">@adman65</a> on
            Twitter or Adman65 on #freenode. Find me in (#rubyonrails or
            #sproutcore). You can find my code on <a href="http://github.com/twinturbo/">GitHub</a> or hit me up on
            <a href="https://plus.google.com/u/0/116377228668850173159">Google+</a>.
          </p>
        </article>
      </div>
    </div>

    <script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '4eb0f672613f5d482f000001');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>

  </body>
</html>
