<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>BroadcastingAdam</title>
    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.8.2r1/build/reset/reset-min.css">
    <link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
    <script type="text/javascript" src="http://yandex.st/highlightjs/5.16/highlight.min.js"></script>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/5.16/styles/github.min.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="container" class='no-header'
      <header>
        <nav>
          <a href="/">Home</a>
          <a href="/nettuts.html">Nettuts</a>
        </nav>
      </header>
      <div id="content" class="post">
        <header >
          <h2>Advanced Caching in Rails</h2>
          <div class='meta'>
            </p> &nbsp; | &nbsp; rails tutorials</p>
          </div>
        </header>
        <article>
          <p>Caching in Rails is covered occasionally. It is covered in very basic detail in the caching <a href='http://guides.rubyonrails.org/caching_with_rails.html'>guide</a>. Advanced caching is left to reader. Here&#8217;s where I come in. I recently read part of Ryan Bigg&#8217;s <a href='http://www.manning.com/katz/'>Rails 3 in Action</a> upcoming Rails book (review in the works) where he covers caching. He does a wonderful job of giving the reader the basic sense of how you can use page, action, and fragment caching. The examples only work well in a simple application like he&#8217;s developing in the book. I&#8217;m going to show you how you can level up your caching with some new approaches.</p>

<h2 id='different_caching_layers'>Different Caching Layers</h2>

<p>First, let&#8217;s start with a brief overview of the different types of caching:</p>

<p>1. Page Caching: <strong>PRAISE THE GODS</strong> if you actually can use page caching in your application. Page caching is the holy grail. Save the entire thing. Don&#8217;t hit the stack &amp; give some prerendered stuff back. Great for worthless applications without authentication and other highly dynamic aspects.</p>

<p>2. Action Caching: Essentially the same as page caching, except all the before filters are run allowing you to check authentication and other stuff that may have prevented the request for rendering.</p>

<p>3. Fragment Caching: Store parts of views in the cache. Usually for caching partials or large bits of HTML that are independent from other parts. IE, a list of top stories or something like that.</p>

<p>4. Rails.cache: All cached content <strong>except cached pages</strong> are stored in the Rails.cache. Cached pages are stored as HTML on disk. We&#8217;ll use the fact that all the cached action and fragment content are simply stored in Rails.cache. You can cache arbitrary content in the Rails cache. You may cache a large complicated query that you don&#8217;t want to wait to reinstantiate a ton of AR::Base objects.</p>

<h2 id='sweepers_lol_wut'>Sweepers: LOL WUT</h2>

<p>Part of this tutorial revolves making it easier to do caching in your application. Many guides like to throw around sweepers all day. Sweepers have their uses. However, most of the time you <strong>don&#8217;t need a sweeper.</strong> This because we can construct the cache key in such a way that it changes as the object is updated. This is exactly how <code>ActiveRecord::Base#cache_key</code> works. You may not be familiar with this method. It basically constructs a key like:</p>

<pre><code>posts/1/123847192387 # last key is @post.updated_at.to_i</code></pre>

<p>So say we had some thing like this in the view</p>

<pre><code>&lt;% cache @post do %&gt;
  &lt;%= render :partial =&gt; &#39;posts/post&#39;, :locals =&gt; {:post =&gt; @post} %&gt;
&lt;% end %&gt;</code></pre>

<p>The cache method will expand the arguments using the <code>cache_key</code> method and generate a key like <code>views/some_file/posts/1/132487328</code> and store the result of the block in the cache with that key. We all know by now that a blog post will have many comments (mostly spam though :( )</p>

<pre><code>class Post &lt; ActiveRecord::Base
  has_many :comments
end

class Comment &lt; ActiveRecord::Base
  belongs_to :post
end</code></pre>

<p>Then in the posts partial we have something along these lines:</p>

<pre><code>&lt;h2&gt;&lt;%= h(@post.title) %&gt;&lt;/h2&gt;
&lt;%= simple_format(@post.content) %&gt;

&lt;% post.comments.each do |comment| %&gt;
  &lt;%= simple_format(comment.message) %&gt;
&lt;% end %&gt;</code></pre>

<p>So what happens when a comment is made? We know we have to expire the that fragment. Question is how? Well, we just tell the comment to touch the post when it&#8217;s updated. This will change the post&#8217;s <code>cache_key</code> and thusly <strong>cause a cache miss</strong> the next time it is request causing the partial to be rerendered. Simply add <code>:touch =&gt; true</code> to the <code>belongs_to</code> association like so:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  belongs_to :post, :touch =&gt; true
end</code></pre>

<p>Whenever a comment is created/saved/updated/destroyed the post&#8217;s <code>updated_at</code> method will change causing a miss. This concept is known as <strong>autoexpiring cache keys</strong>. This is wonderful! Simply because declaring some options in the model layer will make it easier to main performance in the view layer. This works out very nicely in memcached because it uses an LRU (Least Recently Used) replacement policy. That means, when its alloted memory is fill it will make room by deleting the oldest blocks. Everytime a cache hit occurs, it is moved to the top of the list. If a key is never requested it will slowly move to the bottom the stack and be dumped (aka evicted) when something new needs to be stored.</p>

<h2 id='getting_more_milage_from_fragment_caching'>Getting More Milage from Fragment Caching</h2>

<p>I use fragment caching a ton. There are situtations where you want to display the same data a different way. It may be a list of posts, or who know what&#8211;it&#8217;s just a different view of the same data. If you were using a sweeper, you&#8217;d have to keep track of all the different actions that could change the data and sweep accordingly. Luckily for Rails programmers, it&#8217;s very easy to construct cache keys on the fly so you never have to worry about <strong>what they actually are.</strong> We&#8217;ll come back to this point later.</p>

<p>Here&#8217;s our scenario: We have a large fragment that contains the post. We also have a large fragment for metadata and other random stuff in the sidebar. It contains the number of comments, tags, and some other stuff. For this example, <em>it&#8217;s just stuff</em>.</p>

<p>Assume we have two partials:</p>

<pre><code>/views/posts/_post
/views/posts/_meta</code></pre>

<p>This fragments are represenative of the underlying data and will to be expired at the same time. We can create a custom cache key for each framgent like this:</p>

<pre><code>&lt;% cache [@post, &#39;main&#39;] %&gt;
  # render the partial
&lt;% end %&gt;

&lt;% cache [@post, &#39;meta&#39; %] %&gt;
  &lt;%= render :partial =&gt; &#39;meta&#39;, :locals =&gt; {:post =&gt; @post} %&gt;
&lt;% end %&gt;</code></pre>

<p>This will generate two keys: <code>views/something/posts/1/132132487/main</code> and <code>views/something/posts/1/132132487/meta</code>. You can use this to cache many different fragments. Note: I&#8217;ve used a random string of numbers for the timestamp.</p>

<p>You can also call <code>cache</code> with no arguments will used the context of the request to fill in a cache key. This is how the Rails <a href='http://api.rubyonrails.org/classes/ActionController/Caching/Fragments.html'>docs</a> demonstrate it. They also illustrate how you can use call <code>expire_fragment</code> in the sweeper to invalidate it&#8211;but now we know a trick around that.</p>

<p>These fragment caching examples are <strong>not</strong> a good way to actually cache this kind of content. They are merely provided as a example of how you can generate auto-expiring cache keys for your various view fragments. A Blog post is the perfect place to apply action caching. Odds, are the page with the post doesn&#8217;t change much except there filters in place.</p>

<h2 id='auto_expiring_waction_caching'>Auto Expiring w/Action Caching</h2>

<p>We can use auto expiring keys just as before with action caching. Let&#8217;s take a look at a simple controller for showing the post. As an example, we&#8217;ll have a before filter that tracks how many people have been to this page.</p>

<pre><code>class PostsController &lt; ApplicationController
  before_filter :update_view_counter

  def show
    @post = post
  end

  def post
    Post.find params[:id]
  end

  private
  def update_view_counter
    # do stuff
  end
end</code></pre>

<p>We can easily cache the entire action without any extra effort&#8211;and we&#8217;ll never have to sweep it ourself. Here&#8217;s how:</p>

<pre><code>before_filter :update_view_counter

caches_action :post, :cache_path =&gt; proc do |c|
  # c is the instance of the controller handling the request
  c.post_url(c.post, :tag =&gt; c.post.updated_at.to)
end</code></pre>

<p>And there ya have it! Now whenever anyone tries to go to that page will generate a cache key like: <code>example.com/posts/1?tag=1238478174</code>. Options returned by the <code>:cache_path</code> proc will be passed into a route helper similar to <code>post_path</code>. Basically, we end up with a key that&#8217;s equal to calling: <code>post_path(@post, :tag =&gt; 132489739847)</code>. That was easy. You can throw as many parameters (I like to think of them as tags) in there as you like as long as you don&#8217;t overflow your cache store&#8217;s key limits. You may never run into this problem, but there are situtations where you might.</p>

<h2 id='actions_with_many_query_parameters'>Actions with Many Query Parameters</h2>

<p>Let&#8217;s say have a complicated index type action where you allow the user to create all sorts of cool conditions, limits, paginations, orderings, and all that jazz on a user&#8217;s posts. We can cache all these different combinations using action caching. We know that each combination of input parameters has to be cached with a different key than the others. We also do not want to worry about expiring the pages since there are a ton of different combos. Let&#8217;s take a look at a general controller:</p>

<pre><code>class PostsController &lt; ApplicationController

  def index
    @posts = filtered_posts
  end

  private
  def filtered_posts
    # load users posts
    #
    # I&#39;ll leave this code out since you have a good idea
    # of what it&#39;s like to write some nice case statements
    # and other code with a ton of branches :)
    #
    # apply more complicated filter logic
    #
    # return posts
  end
end</code></pre>

<p>How can we generate a unique key for each combination of input parameters? Use a secure cryptographic hash. A secure hash means there are no collisions. This means we will not have a key conflict&#8211;IE a search ordered by the post date and one by the number of comments will never have the same key. We can take all the parameters and dump them into a hashing function (along with the user&#8217;s timestamp) to generate an auto expiring key for all combinations of search parameters! Here&#8217;s the code</p>

<pre><code>require &#39;digest/sha1&#39;
class PostsController &lt; ApplicationController
  # make sure post belongs_to :user, :touch =&gt; true

  caches_action :index, :cache_path =&gt; proc do |c|
    timestamp = User.find(c.params[:user_id]).to_i
    tag = Digest::SHA1.hex_digest(c.params.to_s + timestamp.to_s)
    posts_url(tag)
  end

  # ....
end</code></pre>

<p>Now we&#8217;ll get a key like: <code>example.com/posts?tag=e3282090ae22d23113ab038ce188ae334cc51df7</code>. Granted, you cannot discern what the key is for, but you can cache every combination of input parameters. Not bad for four lines of code.</p>



          <h3>Contact Me</h3>
          <p>
            Find a problem or have a question about this post? <a href="http://twitter.com/Adman65/">@Adman65</a> on
            Twitter or Adman65 on #freenode. Find me in (#rubyonrails or
            #sproutcore). You can find my code on <a href="http://github.com/Adman65/">GitHub</a>
          </p>
        </article>
      </div>
    </div>
  </body>
</html>
